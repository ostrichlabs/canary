/*
==========================================
Copyright (c) 2020-2021 Ostrich Labs

Helper structure to map a bound GL texture to a file name.

Going to use std::hash of the filename as the ID until there's problems. Then I'll figure something else out.
==========================================
*/

#ifndef OSTRICH_GL4_TEXTURE_H
#define OSTRICH_GL4_TEXTURE_H

#include "../common/ost_common.h"

#if (OST_WINDOWS == 1)
#   include <Windows.h> // required for gl.h
#endif

#include <GL/gl.h>
#include <string>
#include "gl4_extensions.h"
#include "../common/image.h"

namespace ostrich {

/////////////////////////////////////////////////
// Manage a texture loaded into GL
// Currently just handles 2D textures with no mipmaps
class GL4Texture {
public:

    /////////////////////////////////////////////////
    // Constructors are all private; use the static factory methods to create GL4Textures
    // Destructor is explicitly defined
    // Copy/move constructors/operators are deleted to prevent deleting the same texture twice
    virtual ~GL4Texture();
    GL4Texture(GL4Texture &&) = delete;
    GL4Texture(const GL4Texture &) = delete;
    GL4Texture &operator=(GL4Texture &&) = delete;
    GL4Texture &operator=(const GL4Texture &) = delete;

    /////////////////////////////////////////////////
    // Load image data into OpenGL
    // Will use ARB_direct_state_access if available
    //
    // in:
    //      ext - GL extension object with pre-loaded functions
    //      image - constructed Image object with valid data
    // returns:
    //      on success, a GL4Texture with a valid GL texture ID and a unique ID generated from a hash function
    //      on failure, a default-constructed object (reference glGetError())
    static GL4Texture CreateTexture(GL4Extensions &ext, const ostrich::Image &image);

    /////////////////////////////////////////////////
    // Force GL to unbind the texture
    // This is a permanent operation; there is no mechanism for re-loading a texture after this is complete
    // Maybe this is a bad idea, but we'll cross that bridge when we get to it
    //
    // returns:
    //      void
    void UnbindTexture();

    /////////////////////////////////////////////////
    // accessor methods
    /////////////////////////////////////////////////
    std::size_t getUniqueID() const noexcept { return m_UniqueID; }
    GLuint getTexObject() const noexcept { return m_Texture; }

private:

    /////////////////////////////////////////////////
    // Default constructor, when no data is available
    GL4Texture() noexcept : m_UniqueID(0), m_Texture(0) {}

    /////////////////////////////////////////////////
    // Creates an object with provided data
    GL4Texture(std::size_t uid, GLuint tex) noexcept : m_UniqueID(uid), m_Texture(tex) {}

    /////////////////////////////////////////////////
    // Helper function to create a GL texture using core GL functions
    //
    // in:
    //      ext - GL extension object with pre-loaded functions
    //      image - constructed Image object with valid data
    //      GLinternalformat - GL_RGB, GL_RGBA, or a compressed format like GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
    //      GLpixelformat - GL_RGB/A or their reverse
    // returns:
    //      a texture name generated by OpenGL
    static GLuint CreateTextureCore(GL4Extensions &ext, const ostrich::Image &image, GLint GLinternalformat, GLenum GLpixelformat);

    /////////////////////////////////////////////////
    // Helper function to create a GL texture using ARB_direct_state_access
    //
    // in:
    //      ext - GL extension object with pre-loaded functions
    //      image - constructed Image object with valid data
    //      GLinternalformat - GL_RGB, GL_RGBA, or a compressed format like GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
    //      GLpixelformat - GL_RGB/A or their reverse
    // returns:
    //      a texture name generated by OpenGL
    static GLuint CreateTextureObject(GL4Extensions &ext, const ostrich::Image &image, GLint GLinternalformat, GLenum GLpixelformat);

    /////////////////////////////////////////////////
    // Helper function to detect GL texture formats based on ostrich::PixelFormat
    //
    // in:
    //      ostformat - ostrich internal pixel format
    // out:
    //      GLinternalformat - GL_RGB, GL_RGBA, or a compressed format like GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
    //      GLpixelformat - GL_RGB/A or their reverse
    // returns:
    //      true if two formats were found
    static bool GetGLFormats(ostrich::PixelFormat ostformat, GLint &GLinternalformat, GLenum &GLpixelformat);

    std::size_t m_UniqueID;
    GLuint m_Texture;
};

} // namespace ostrich

#endif /* OSTRICH_GL4_TEXTURE_H */
